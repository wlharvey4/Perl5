0\input texinfo   @c -*- mode: texinfo -*-

@c FILE    Perl5.twjr
@c VERSION 0.1.1
@c DATE    2018-11-12T15:20
@c AUTHOR  wlharvey4

@c *****************************************************************************
@c %**start of header

@setfilename  Perl5.info
@settitle     All About Perl5

@c %**end of header
@c *****************************************************************************

@c -----------------------------------------------------------------------------
@set TITLE      All About Perl5
@set SHORTTITLE Perl5
@set AUTHOR WLHarvery4
@set EDITION 0.1
@set UPDATE-MONTH NOVEMBER, 2018 @c goes in the subtitle
@set COPYRIGHT-YEAR 2018
@set COPYRIGHT-HOLDER WLHarvey4
@set ADDRESS1 Address Line 1
@set ADDRESS2 Address Line 2
@c -----------------------------------------------------------------------------








@c *****************************************************************************
@c BIBCITE MACROS
@c *****************************************************************************

@c need to load macros before header
@macro mybibsetrefnode{node}
@set mybibrefnode \node\
@end macro

@macro mybibnode{}
@value{mybibrefnode}
@end macro

@macro mybibusetable{node}
@set mybibtable true
@ifset mybiblist
@clear mybiblist
@end ifset
@mybibsetrefnode{\node\}
@end macro

@macro mybibuselist{node}
@set mybiblist true
@ifset mybibtable
@clear mybibtable
@end ifset
@mybibsetrefnode{\node\}
@end macro

@macro mybibcite{ref}
@inlineifclear{mybibrefnode, @mybibmakeref{mybibsetrefnode was not used, \ref\}}
@ifset mybibrefnode
@mybibmakeref{@mybibnode{}, \ref\}
@end ifset

@end macro

@macro mybibmakeref{node, ref}
(See item @cite{\ref\} in @ref{\ref\,,\node\}.)
@end macro

@macro mybibitem{ref}
@ifclear mybiblist
@ifclear mybibtable
@set mybiblist true
@end ifclear
@end ifclear

@ifset mybiblist
@item
@anchor{\ref\}[\ref\]
@end ifset

@ifset mybibtable
@item @anchor{\ref\}\ref\ ---
@end ifset

@end macro

@mybibusetable{Bibliography}

@c /////////////////////////////////////////////////////////////////////////////








@c *****************************************************************************
@c FINALOUT / DRAFT / FORPRINT
@c *****************************************************************************

@set      DRAFT @i{DRAFT} @c when set, print DRAFT in heading
@c @clear DRAFT  @c when clear, don't print DRAFT in heading
@clear  FINALOUT @c when clear, show black boxes for overfull lines
@c @set FINALOUT @c when set, don't show black boxes for overfull lines
@clear  FORPRINT @c when clear, PDF output is for viewing, not printing
@c @set FORPRINT @c when set, PDF output is for printing, not viewing

@c -----------------------------------------------------------------------------
@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear

@iftex
@ifset FINALOUT @c don't show black boxes for final printout
@finalout
@end ifset
@end iftex

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@ifset FORPRINT
@ifset FINALOUT
@c @setchapternewpage odd
@end ifset
@end ifset

@c -----------------------------------------------------------------------------








@c *****************************************************************************
@c SECTIONING / INDICES
@c *****************************************************************************

@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook


@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c /////////////////////////////////////////////////////////////////////////////








@c *****************************************************************************
@c SPECIAL TEXIWEBJR COMMANDS
@c *****************************************************************************

@c Change how xref titles are quoted.
@dquotexrefs
@c And let braces in index entries work.
@allowindexbraces

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex


@c -----------------------------------------------------------------------------
@c INITIAL_SETUP
@c -----------------------------------------------------------------------------

@c The initial_setup code runs as a script in a BEGIN section of AWK during the
@c tangling  phase before  any files  are  extracted. Here  create a  directory
@c structure for project  files, plus any other initialization  that might need
@c to be done. Files are moved into directories in a @post_create command.

@initial_setup
printf "${YELLOW}In initial_setup...${BLUEBOLD}\n"

ROOT=${PWD}
FILES="files"
SUBDIRS="lib src doc t bin"

for subdir in ${SUBDIRS}
do
    ! [ -d ${ROOT}/${FILES}/${subdir} ] && {
       mkdir -vp ${ROOT}/${FILES}/${subdir} && \
       printf "${BLUEBOLD}created directory ${PURPLEBOLD}."$(basename ${ROOT})"/${FILES}/${subdir}${CLEAR}\n" || \
      printf "${RED}failed to create directory ${PURPLEBOLD}${ROOT}/${FILES}/${subdir}${CLEAR}\n"
    } || \
      printf "${BLUEBOLD}file ${PURPLEBOLD}."$(basename ${ROOT})"/${FILES}/${subdir} exists${CLEAR}\n"
done

printf "${YELLOW}Looking for ${CYAN}git repo...${CLEAR}"
if ! [ -e ./.git ]
then
        printf "${BLUE}initializing git repo${PURPLE}\n"
        git init
        [ -e ./.git ] && \
          printf "${GREEN}git initialized.${CLEAR}\n" || \
          printf "${RED}failed to initialize git.${CLEAR}\n"
else
        printf "${GREEN}found ${PURPLEBOLD}.git.${CLEAR}\n"
fi

printf "${YELLOW}looking for ${CYAN}.gitignore...${CLEAR}"
if ! [ -e ./.gitignore ]
then
        printf "${BLUE}creating...${CLEAR}"
        echo '.lodestone' > ./.gitignore
        [ -e ./.gitignore ] && \
          printf "${GREEN}created${PURPLEBOLD}.gitignore${CLEAR}\n" || \
          printf "${RED}failed${CLEAR}\n"
else
        printf "${GREEN}found ${PURPLEBOLD}.gitignore.${GREEN}\n"
fi

printf "${GREEN}initial setup done.${CLEAR}\n"

@end initial_setup
@c <------------------------------------->

@c END Special TexiwebJr Commands
@c /////////////////////////////////////////////////////////////////////////////








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN COPYING
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


@copying

@c <------------------------------------->
@docbook
<para>Published by:</para>

<literallayout class="normal">Full Name
Address Line 1
Address Line 2
etc.
Email: <email>user@@example.com</email>
URL: <ulink url="http://www.example.com/">http://www.example.com/</ulink></literallayout>

<literallayout class="normal">Copyright &copy; YYYY, YYYY
Full name here
All Rights Reserved.</literallayout>
@end docbook
@c <------------------------------------->


@c <------------------------------------->
@ifnotdocbook
Copyright @copyright{} @value{COPYRIGHT-YEAR} @*
@value{AUTHOR} @*
All Rights Reserved.
@end ifnotdocbook
@c <------------------------------------->


@sp 1
@value{TITLE} is copyright @value{COPYRIGHT-YEAR}
@copyright{} by @value{AUTHOR}. It is published under the conditions of the GNU
General Public License, version 3.
@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.


@end copying
@c /////////////////////////////////////////////////////////////////////////////








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN TITLEPAGE
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


@titlepage

@c Uncomment this if it's ever printed as a real book(let).
@c @shorttitlepage @value{SHORTTITLE}

@title @value{TITLE}
@subtitle @value{UPDATE-MONTH}
@author @value{AUTHOR} @c Full Name here

@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
@value{AUTHOR} @*
@value{ADDRESS1} @*
@value{ADDRESS2} @*
@* @c etc.
Email: @EMAIL{user@@example.com,user AT example.com} @*
URL: @url{http://www.example.com/} @*

@insertcopying
@end ifnotdocbook
@c <------------------------------------->


@end titlepage
@c /////////////////////////////////////////////////////////////////////////////








@c =============================================================================
@c HEADINGS SETTINGS
@c =============================================================================

@iftex
@headings off
@evenheading @thispage @| @value{DRAFT} @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| @value{DRAFT} @| @thispage
@end iftex

@c /////////////////////////////////////////////////////////////////////////////








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN TOP
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%








@ifnottex
@ifnotdocbook
@ifnotxml

@c =============================================================================
@node Top
@top Top of the Perl
@c =============================================================================

This file documents @value{TITLE}.

@insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex




@c -----------------------------------------------------------------------------
@c                                  MENU & TOC

@c <------------------------------------->
@c                 MENU

@menu

@detailmenu

@end detailmenu
@end menu
@c <------------------------------------->




@c <------------------------------------->
@c                 TOC

@c @summarycontents
@contents

@c <------------------------------------->

@c -----------------------------------------------------------------------------


@c END MENU & TOC
@c /////////////////////////////////////////////////////////////////////////////








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@part Front Matter

@c BEGIN FRONT-MATTER
@c --Forward
@c --Preface
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%








@c *****************************************************************************
@c                                  FORWARD

@c @node Foreword
@c @unnumbered Foreword


@c END Forward
@c /////////////////////////////////////////////////////////////////////////////








@c *****************************************************************************
@c                                  PREFACE

@node Preface
@unnumbered Preface

Text here.

@menu
* Audience::                    Who should read this @value{DOCUMENT}.
* Overview::                    An overview of the @value{DOCUMENT}.
* Conventions::                 Typographical conventions.
* Acknowledgements::            Acknowledgements.
@end menu




@c -----------------------------------------------------------------------------
@node Audience
@unnumberedsec Intended Audience

Audience text here.




@c -----------------------------------------------------------------------------
@node Overview
@unnumberedsec What Is Covered

Overview text and chapter by chapter description here.


@c .....................................

@node The Readme
@unnumberedsubsec The Readme
@cindex readme

@(README.md@)=
# Perl5

## About This Source File

This document (`Perl5.twjr`) is a *literate* source document. It is designed to
produce an `Info` file (best read from within Emacs, but there is a stand-alone
Info reader  that can be used),  a `Pdf` document (generated  from LaTeX source
code by PDFTeX), an `HTML` web  site, `Docbook` source code, an `XML` document,
and a plain  text document. In addition.  it also produces working  code in any
language (so long as your system  contains the infrastructure to run the code).
For example,  this `README` file  was drafted  within this source  document and
extracted  as a  separate file,  as was  also the  `Makefile`. This  *literate*
document's features are targeted via a custom `Makefile` that is also a part of
this document, and  extracted as a separate  file, and is dynamic  in the sense
that if you  update it, you can produce  a new version with a simple  call to a
`make` target.  It is  designed to  be able  to produce  any number  of working
software  packages  of  any  language  contained at  any  number  of  different
locations on your system, all with  a single or, alternatively, multiple `make`
calls, depending on the granularity you need.

The Github  repository contains this  source document,  a Makefile that  can be
used  to work  with the  project, as  well as  a `Texinfo`  file that  has been
generated from  this `Twjr` file,  this README,  and a `.gitignore`  file. Most
computer systems have or can easily get the `make`, and `texinfo` programs that
are needed to  process the `Texinfo` file into the  various end documents, such
as `Info`,  `Pdf`, `HTML`, etc. Your  system will need, in  addition to `make`,
and `texinfo`, Gnu  AWK (`gawk`), and TexiwebJr to make  changes to this source
document and  process it  into a  `Texinfo` file and  extract its  programs and
files.  Your system  should also  have  the equivalent  of Bash  version 4,  as
version 4  has some parameter capabilities  that earlier versions do  not. Note
that most  versions of Mac OS  have version 3  of Bash installed as  a default.
Version 4 can be added using Homebrew or MacPorts very easily. In the past, Mac
OS has  also shipped with a  version of `texinfo`  that is below 6.5.  You will
also need to update `texinfo` to at least 6.5 if that is the case.

## How It Works

## Resources

* [TexiwebJr](https://github.com/arnoldrobbins/texiwebjr)
* [Texinfo](https://www.gnu.org/software/texinfo/)
* [Gnu AWK (gawk)](https://www.gnu.org/software/gawk/)
* [Gnu Bash](https://www.gnu.org/software/bash/)
* [TeX Live](https://www.tug.org/texlive/)

@




@c -----------------------------------------------------------------------------
@node Conventions
@unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{http://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo




@c -----------------------------------------------------------------------------
@node Acknowledgements
@unnumberedsec Acknowledgements

Acknowledgements go here.


@c END Preface
@c /////////////////////////////////////////////////////////////////////////////








@c *****************************************************************************
@c                          CHAPTER: Introduction

@node Introduction
@chapter Introduction



@c END CHAPTER Introduction
@c /////////////////////////////////////////////////////////////////////////////





@c *****************************************************************************
@c	 	             CHAPTER: Perlbrew

@node Perlbrew
@chapter PerlBrew
@cindex perlbrew

@url{https://perlbrew.pl/, Perlbrew Home}

@noindent
@url{https://metacpan.org/pod/App::perlbrew, Perlbrew MetaCPAN}

@noindent
@url{https://github.com/gugod/App-perlbrew, Perlbrew on Github}

@heading About

@command{perlbrew}  is an  admin-free perl  installation management  tool.  The
latest version is  0.84.  @command{perlbrew} is a tool to  manage multiple perl
installations  in your  @file{$HOME} directory.   They are  completely isolated
perl universes.  This approach has many benefits:

@itemize
@item
No need to run sudo to install CPAN modules, any more.
@item
Try the monthly released new perls.
@item
Learn new language features.
@item
Test your production code against different perl versions.
@item
Leave vendor perl (the one that comes with OS) alone
@item
Hacking perl internals.
@item
Just to keep up with fashion.
@end itemize

While  the  default  is  good  enough,  you may  customize  it  to  install  to
alternative  places,  or even  let  multiple  users  share the  whole  perlbrew
environment.




@c -----------------------------------------------------------------------------

@node Install Perlbrew
@section Install Perlbrew
@cindex install perlbrew
@cindex perlbrew installation

@heading Root Directory
@cindex root directory
@cindex perlbrew default root directory
@cindex PERLBREW_ROOT

The default @command{perlbrew} root directory is @file{~/perl5/perlbrew}, which
can be changed  by setting @env{PERLBREW_ROOT} environment  variable before the
installation  and  initialization.   For more  advanced  installation  process,
please   read   the   @url{http://metacpan.org/module/App::perlbrew,   perlbrew
document}.

@heading Download

Use one of these commands:

@example
\curl -L https://install.perlbrew.pl | bash

# Linux
\wget -O - https://install.perlbrew.pl | bash

# FreeBSD
\fetch -o- https://install.perlbrew.pl | sh
@end example

@heading With @command{cpan}

If you prefer to install with cpan, there are two steps:

@enumerate
@item
@samp{sudo cpan App::perlbrew}
@item
@samp{perlbrew init}
@end enumerate

If  it  is installed  with  @command{cpan},  the @command{perlbrew}  executable
should       be       installed      as       @file{/usr/bin/perlbrew}       or
@file{/usr/local/bin/perlbrew}.   For all  users who  want to  use perlbrew,  a
prior @command{perlbrew init} needs to be executed.




@c -----------------------------------------------------------------------------

@node Using Perlbrew
@section Using Perlbrew
@cindex perlbrew, using




@c -----------------------------------------------------------------------------

@node Perlbrew Articles
@section Perlbrew Articles
@cindex perlbrew articles

@table @cite

@cindex multiple installations
@item Managing Multiple Perl 5 Installations with Perlbrew (BSD Magazine, Volume 12, n. 1, issue 01/2018)
@url{https://bsdmag.org/download/build-scalable-monitoring-system-grafana-influxdb-riemann/}

@cindex deploying perl bindings
@cindex Homebrew
@item Deploying Perl bindings from tools installed with Homebrew on OS X
@url{https://perlbrew.pl/Deploying-Perl-bindings-from-tools-installed-with-Homebrew-on-OS-X.html}

@cindex perlbrew configuration
@item Perlbrew Configuration
@url{https://perlbrew.pl/Perlbrew-Configuration.html}

@cindex perlbrew, reinstall all modules
@cindex modules, reinstall using perlbrew
@item Reinstall All Modules On New Perl
@url{https://perlbrew.pl/Reinstall-All-Modules-On-New-Perl.html}

@cindex @file{sitecustomize.pl}, perlbrew
@cindex perlbrew, @file{sitecustomize.pl}
@item Install a sitecustomize.pl file with perlbrew
@url{https://perlbrew.pl/Install-a-sitecustomize.pl-file-with-perlbrew.html}

@cindex perlbrew and git
@item Perlbrew development and the git flow
@url{https://perlbrew.pl/Perlbrew-development-and-the-git-flow.html}

@cindex perlbrew in shell scripts
@cindex shell scripts using perlbrew
@cindex scripts, shell and perlbrew
@item Perlbrew In Shell Scripts
@url{https://perlbrew.pl/Perlbrew-In-Shell-Scripts.html}

@cindex friends of perlbrew
@cindex perlbrew and friends
@item Perlbrew and Friends
@url{https://perlbrew.pl/Perlbrew-and-Friends.html}

@end table


@c .....................................

@node Multiple Perl 5 Installations
@subsection Managing Multiple Perl 5 Installations
@cindex multiple perl5 installations with perlbrew
@cindex installations, multiple with perlbrew

@quotation
Perl 5 is a very stable, feature-rich, programming language used in a multitude
of environments and applications,  including operating system management tasks.
Perl  5  is available  in  several  versions,  and  usually, all  versions  are
backwards compatible. However, there are edge cases and new features that could
not be available on all versions. When dealing with Perl 5 application, it is a
relief to know  that the exact version required can  be installed, depending on
the  specific  feature  set  or   compatibility,  without  having  to  ask  for
administrator  privileges  or the  need  to  touch  the  system’s wide  Perl  5
installation. Perlbrew allows exactly that.
@author BSD Magazine
@end quotation

@heading About This Article
This paper  introduces Perlbrew, providing  simple instructions how  to install
and run.

@c _____________________________________

@node Installing Perlbrew
@subsubsection Installing Perlbrew
@cindex install perlbrew

There are three main ways to install perlbrew:

@enumerate
@item
Using the ports collection (the port is @file{devel/p5-App-perlbrew});
@item
By manually downloading and installing the  latest version from the project web
site;
@item
By installing it from the CPAN (the name is @file{App::Perlbrew}).
@end enumerate

@c _____________________________________

@node Project Web Site
@subsubsection Installing From The Project Web Site
@cindex install from project site

Getting the program from the project web  site provides a better control on its
installation, as well as an always up-to-date version.



@c END SECTION: Perlbrew Articles
@c /////////////////////////////////////////////////////////////////////////////



@c END CHAPTER: Perlbrew
@c /////////////////////////////////////////////////////////////////////////////







@c *****************************************************************************
@c                            CHAPTER: Packages

@node About Packages
@chapter About Packages
@cindex about packages
@cindex packages, about




@c -----------------------------------------------------------------------------
@c                          SECTION: File::Slurp

@node About File-Slurp
@section About File::Slurp
@cindex about @file{File::Slurp}
@cindex @file{File::Slurp}, about

@heading About @file{File::Slurp}

Simple and Efficient Reading/Writing/Modifying of Complete Files

@url{https://github.com/perhunter/slurp, @file{File::Slurp} on Github}

@url{https://metacpan.org/release/File-Slurp, @file{File::Slurp} on MetaCPAN}

@subheading Current Version

@file{File::Slurp-9999.24} as of 2018-10-29


@c .....................................

@node File-Slurp Manifest
@subsection @file{File::Slurp} Manifest
@cindex @file{File::Slurp} manifest
@cindex manifest for @file{File::Slurp}

@verbatim
.appveyor.cmd
.appveyor.yml
.mailmap
.travis.yml
Changes
lib/File/Slurp.pm
Makefile.PL
MANIFEST
MANIFEST.SKIP
META.json                       Module meta-data (added by MakeMaker)
README.md
t/00-report-prereqs.t
t/01-error_edit_file.t
t/01-error_edit_file_lines.t
t/01-error_prepend_file.t
t/01-error_read_dir.t
t/01-error_read_file.t
t/01-error_write_file.t
t/append_null.t
t/binmode.t
t/data_section.t
t/edit_file.t
t/error.t
t/file_object.t
t/handle.t
t/inode.t
t/large.t
t/lib/FileSlurpTest.pm
t/lib/FileSlurpTestOverride.pm
t/newline.t
t/no_clobber.t
t/original.t
t/paragraph.t
t/perms.t
t/prepend_file.t
t/pseudo.t
t/read_dir.t
t/slurp.t
t/stdin.t
t/stringify.t
t/tainted.t
t/write_file_win32.t
xt/author/00-compile.t
xt/author/eol.t
xt/author/pod-spell.t
xt/author/pod-syntax.t
xt/author/pod_coverage.t
xt/author/test-version.t
META.yml
@end verbatim


@c .....................................

@node File-Slurp Code
@subsection @file{File::Slurp} Code
@cindex @file{File::Slurp} code

@(Slurp.pm@)=
@<Package---File--Slurp-Code@>
@<Package---File--Slurp-Perldoc@>

@

@post_create Slurp.pm printf "${PURPLE}"; mkdir -vp ${PWD}/files/lib/File; mv -v Slurp.pm "${PWD}/files/lib/File" && printf "${GREEN}done moving ${PURPLEBOLD}Slurp.pm.${CLEAR}\n" || printf "${RED}failed.${CLEAR}\n"


@c _____________________________________

@node Package File-Slurp
@subsubsection Package File::Slurp
@cindex package file::Slurp

@<Package---File--Slurp-Code@>=
package File::Slurp;

use strict;
use warnings ;

our $VERSION = '9999.24';
$VERSION = eval $VERSION;

use Carp ;
use Exporter qw(import);
use Fcntl qw( :DEFAULT ) ;
use File::Spec;
use POSIX qw( :fcntl_h ) ;
use Errno ;

my @std_export = qw(
        read_file
        write_file
        overwrite_file
        append_file
        read_dir
) ;

my @edit_export = qw(
        edit_file
        edit_file_lines
) ;

my @abbrev_export = qw(
        rf
        wf
        ef
        efl
) ;

our @EXPORT_OK = (
        @edit_export,
        @abbrev_export,
        qw(
                slurp
                prepend_file
        ),
) ;

our %EXPORT_TAGS = (
        'all'   => [ @std_export, @edit_export, @abbrev_export, @EXPORT_OK ],
        'edit'  => [ @edit_export ],
        'std'   => [ @std_export ],
        'abr'   => [ @abbrev_export ],
) ;

our @EXPORT = @std_export ;

my $max_fast_slurp_size = 1024 * 100 ;

my $is_win32 = $^O =~ /win32/i ;

*slurp = \&read_file ;
*rf = \&read_file ;

sub read_file {

        my $file_name = shift ;
        my $opts = ( ref $_[0] eq 'HASH' ) ? shift : { @_ } ;

# this is the optimized read_file for shorter files.
# the test for -s > 0 is to allow pseudo files to be read with the
# regular loop since they return a size of 0.

        if ( !ref $file_name && -e $file_name && -s _ > 0 &&
             -s _ < $max_fast_slurp_size && !%{$opts} && !wantarray ) {


                my $fh ;
                unless( sysopen( $fh, $file_name, O_RDONLY ) ) {

                        @_ = ( $opts, "read_file '$file_name' - sysopen: $!");
                        goto &_error ;
                }

                my $read_cnt = sysread( $fh, my $buf, -s _ ) ;

                unless ( defined $read_cnt ) {

                        @_ = ( $opts,
                                "read_file '$file_name' - small sysread: $!");
                        goto &_error ;
                }

                $buf =~ s/\015\012/\n/g if $is_win32 ;
                return $buf ;
        }

# set the buffer to either the passed in one or ours and init it to the null
# string

        my $buf ;
        my $buf_ref = $opts->{'buf_ref'} || \$buf ;
        ${$buf_ref} = '' ;

        my( $read_fh, $size_left, $blk_size ) ;

# deal with ref for a file name
# it could be an open handle or an overloaded object

        if ( ref $file_name ) {

                my $ref_result = _check_ref( $file_name ) ;

                if ( ref $ref_result ) {

# we got an error, deal with it

                        @_ = ( $opts, $ref_result ) ;
                        goto &_error ;
                }

                if ( $ref_result ) {

# we got an overloaded object and the result is the stringified value
# use it as the file name

                        $file_name = $ref_result ;
                }
                else {

# here we have just an open handle. set $read_fh so we don't do a sysopen

                        $read_fh = $file_name ;
                        $blk_size = $opts->{'blk_size'} || 1024 * 1024 ;
                        $size_left = $blk_size ;
                }
        }

# see if we have a path we need to open

        unless ( $read_fh ) {

# a regular file. set the sysopen mode

                my $mode = O_RDONLY ;

#printf "RD: BINARY %x MODE %x\n", O_BINARY, $mode ;

                $read_fh = local( *FH ) ;
#               $read_fh = gensym ;
                unless ( sysopen( $read_fh, $file_name, $mode ) ) {
                        @_ = ( $opts, "read_file '$file_name' - sysopen: $!");
                        goto &_error ;
                }

                if ( my $binmode = $opts->{'binmode'} ) {
                        binmode( $read_fh, $binmode ) ;
                }

# get the size of the file for use in the read loop

                $size_left = -s $read_fh ;

#print "SIZE $size_left\n" ;

# we need a blk_size if the size is 0 so we can handle pseudofiles like in
# /proc. these show as 0 size but have data to be slurped.

                unless( $size_left ) {

                        $blk_size = $opts->{'blk_size'} || 1024 * 1024 ;
                        $size_left = $blk_size ;
                }
        }

# infinite read loop. we exit when we are done slurping

        while( 1 ) {

# do the read and see how much we got

                my $read_cnt = sysread( $read_fh, ${$buf_ref},
                                $size_left, length ${$buf_ref} ) ;

# since we're using sysread Perl won't automatically restart the call
# when interrupted by a signal.

                next if $!{EINTR};

                unless ( defined $read_cnt ) {

                        @_ = ( $opts, "read_file '$file_name' - loop sysread: $!");
                        goto &_error ;
                }

# good read. see if we hit EOF (nothing left to read)

                last if $read_cnt == 0 ;

# loop if we are slurping a handle. we don't track $size_left then.

                next if $blk_size ;

# count down how much we read and loop if we have more to read.

                $size_left -= $read_cnt ;
                last if $size_left <= 0 ;
        }

# fix up cr/lf to be a newline if this is a windows text file

        ${$buf_ref} =~ s/\015\012/\n/g if $is_win32 && !$opts->{'binmode'} ;

        my $sep = $/ ;
        $sep = '\n\n+' if defined $sep && $sep eq '' ;

# see if caller wants lines

        if( wantarray || $opts->{'array_ref'} ) {

                use re 'taint' ;

                my @lines = length(${$buf_ref}) ?
                        ${$buf_ref} =~ /(.*?$sep|.+)/sg : () ;

                chomp @lines if $opts->{'chomp'} ;

# caller wants an array ref

                return \@lines if $opts->{'array_ref'} ;

# caller wants list of lines

                return @lines ;
        }

# caller wants a scalar ref to the slurped text

        return $buf_ref if $opts->{'scalar_ref'} ;

# caller wants a scalar with the slurped text (normal scalar context)

        return ${$buf_ref} if defined wantarray ;

# caller passed in an i/o buffer by reference (normal void context)

        return ;
}

# errors in this sub are returned as scalar refs
# a normal IO/GLOB handle is an empty return
# an overloaded object returns its stringified as a scalarfilename

sub _check_ref {

        my( $handle ) = @_ ;

# check if we are reading from a handle (GLOB or IO object)

        if ( eval { $handle->isa( 'GLOB' ) || $handle->isa( 'IO' ) } ) {

# we have a handle. deal with seeking to it if it is DATA

                my $err = _seek_data_handle( $handle ) ;

# return the error string if any

                return \$err if $err ;

# we have good handle
                return ;
        }

        eval { require overload } ;

# return an error if we can't load the overload pragma
# or if the object isn't overloaded

        return \"Bad handle '$handle' is not a GLOB or IO object or overloaded"
                 if $@ || !overload::Overloaded( $handle ) ;

# must be overloaded so return its stringified value

        return "$handle" ;
}

sub _seek_data_handle {

        my( $handle ) = @_ ;

# DEEP DARK MAGIC. this checks the UNTAINT IO flag of a
# glob/handle. only the DATA handle is untainted (since it is from
# trusted data in the source file). this allows us to test if this is
# the DATA handle and then to do a sysseek to make sure it gets
# slurped correctly. on some systems, the buffered i/o pointer is not
# left at the same place as the fd pointer. this sysseek makes them
# the same so slurping with sysread will work.

        eval{ require B } ;

        if ( $@ ) {

                return <<ERR ;
Can't find B.pm with this Perl: $!.
That module is needed to properly slurp the DATA handle.
ERR
        }

        if ( B::svref_2object( $handle )->IO->IoFLAGS & 16 ) {

# set the seek position to the current tell.

                unless( sysseek( $handle, tell( $handle ), SEEK_SET ) ) {
                        return "read_file '$handle' - sysseek: $!" ;
                }
        }

# seek was successful, return no error string

        return ;
}


*wf = \&write_file ;

sub write_file {

        my $file_name = shift ;

# get the optional argument hash ref from @_ or an empty hash ref.

        my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;

        my( $buf_ref, $write_fh, $no_truncate, $orig_file_name, $data_is_ref ) ;

# get the buffer ref - it depends on how the data is passed into write_file
# after this if/else $buf_ref will have a scalar ref to the data.

        if ( ref $opts->{'buf_ref'} eq 'SCALAR' ) {

# a scalar ref passed in %opts has the data
# note that the data was passed by ref

                $buf_ref = $opts->{'buf_ref'} ;
                $data_is_ref = 1 ;
        }
        elsif ( ref $_[0] eq 'SCALAR' ) {

# the first value in @_ is the scalar ref to the data
# note that the data was passed by ref

                $buf_ref = shift ;
                $data_is_ref = 1 ;
        }
        elsif ( ref $_[0] eq 'ARRAY' ) {

# the first value in @_ is the array ref to the data so join it.

                ${$buf_ref} = join '', @{$_[0]} ;
        }
        else {

# good old @_ has all the data so join it.

                ${$buf_ref} = join '', @_ ;
        }

# deal with ref for a file name

        if ( ref $file_name ) {

                my $ref_result = _check_ref( $file_name ) ;

                if ( ref $ref_result ) {

# we got an error, deal with it

                        @_ = ( $opts, $ref_result ) ;
                        goto &_error ;
                }

                if ( $ref_result ) {

# we got an overloaded object and the result is the stringified value
# use it as the file name

                        $file_name = $ref_result ;
                }
                else {

# we now have a proper handle ref.
# make sure we don't call truncate on it.

                        $write_fh = $file_name ;
                        $no_truncate = 1 ;
                }
        }

# see if we have a path we need to open

        unless( $write_fh ) {

# spew to regular file.

                if ( $opts->{'atomic'} ) {

# in atomic mode, we spew to a temp file so make one and save the original
# file name.
                        $orig_file_name = $file_name ;
                        $file_name .= ".$$" ;
                }

# set the mode for the sysopen

                my $mode = O_WRONLY | O_CREAT ;
                $mode |= O_APPEND if $opts->{'append'} ;
                $mode |= O_EXCL if $opts->{'no_clobber'} ;

                my $perms = $opts->{perms} ;
                $perms = 0666 unless defined $perms ;

#printf "WR: BINARY %x MODE %x\n", O_BINARY, $mode ;

# open the file and handle any error.

                $write_fh = local( *FH ) ;
#               $write_fh = gensym ;
                unless ( sysopen( $write_fh, $file_name, $mode, $perms ) ) {

                        @_ = ( $opts, "write_file '$file_name' - sysopen: $!");
                        goto &_error ;
                }
        }

        if ( my $binmode = $opts->{'binmode'} ) {
                binmode( $write_fh, $binmode ) ;
        }

        sysseek( $write_fh, 0, SEEK_END ) if $opts->{'append'} ;

#print 'WR before data ', unpack( 'H*', ${$buf_ref}), "\n" ;

# fix up newline to write cr/lf if this is a windows text file

        if ( $is_win32 && !$opts->{'binmode'} ) {

# copy the write data if it was passed by ref so we don't clobber the
# caller's data
                $buf_ref = \do{ my $copy = ${$buf_ref}; } if $data_is_ref ;
                ${$buf_ref} =~ s/\n/\015\012/g ;
        }

#print 'after data ', unpack( 'H*', ${$buf_ref}), "\n" ;

# get the size of how much we are writing and init the offset into that buffer

        my $size_left = length( ${$buf_ref} ) ;
        my $offset = 0 ;

# loop until we have no more data left to write

        do {

# do the write and track how much we just wrote

                my $write_cnt = syswrite( $write_fh, ${$buf_ref},
                                $size_left, $offset ) ;

# since we're using syswrite Perl won't automatically restart the call
# when interrupted by a signal.

                next if $!{EINTR};

                unless ( defined $write_cnt ) {

                        @_ = ( $opts, "write_file '$file_name' - syswrite: $!");
                        goto &_error ;
                }

# track how much left to write and where to write from in the buffer

                $size_left -= $write_cnt ;
                $offset += $write_cnt ;

        } while( $size_left > 0 ) ;

# we truncate regular files in case we overwrite a long file with a shorter file
# so seek to the current position to get it (same as tell()).

        truncate( $write_fh,
                  sysseek( $write_fh, 0, SEEK_CUR ) ) unless $no_truncate ;

        close( $write_fh ) ;

# handle the atomic mode - move the temp file to the original filename.

        if ( $opts->{'atomic'} && !rename( $file_name, $orig_file_name ) ) {

                @_ = ( $opts, "write_file '$file_name' - rename: $!" ) ;
                goto &_error ;
        }

        return 1 ;
}

# this is for backwards compatibility with the previous File::Slurp module.
# write_file always overwrites an existing file

*overwrite_file = \&write_file ;

# the current write_file has an append mode so we use that. this
# supports the same API with an optional second argument which is a
# hash ref of options.

sub append_file {

# get the optional opts hash ref
        my $opts = $_[1] ;
        if ( ref $opts eq 'HASH' ) {

# we were passed an opts ref so just mark the append mode

                $opts->{append} = 1 ;
        }
        else {

# no opts hash so insert one with the append mode

                splice( @_, 1, 0, { append => 1 } ) ;
        }

# magic goto the main write_file sub. this overlays the sub without touching
# the stack or @_

        goto &write_file
}

# prepend data to the beginning of a file

sub prepend_file {

        my $file_name = shift ;

#print "FILE $file_name\n" ;

        my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;

# delete unsupported options

        my @bad_opts =
                grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;

        delete @{$opts}{@bad_opts} ;

        my $prepend_data = shift ;
        $prepend_data = '' unless defined $prepend_data ;
        $prepend_data = ${$prepend_data} if ref $prepend_data eq 'SCALAR' ;

#print "PRE [$prepend_data]\n" ;

        my $err_mode = delete $opts->{err_mode} ;
        $opts->{ err_mode } = 'croak' ;
        $opts->{ scalar_ref } = 1 ;

        my $existing_data = eval { read_file( $file_name, $opts ) } ;

        if ( $@ ) {

                @_ = ( { err_mode => $err_mode },
                        "prepend_file '$file_name' - read_file: $!" ) ;
                goto &_error ;
        }

#print "EXIST [$$existing_data]\n" ;

        $opts->{atomic} = 1 ;
        my $write_result =
                eval { write_file( $file_name, $opts,
                       $prepend_data, $$existing_data ) ;
        } ;

        if ( $@ ) {

                @_ = ( { err_mode => $err_mode },
                        "prepend_file '$file_name' - write_file: $!" ) ;
                goto &_error ;
        }

        return $write_result ;
}

# edit a file as a scalar in $_

*ef = \&edit_file ;

sub edit_file(&$;$) {

        my( $edit_code, $file_name, $opts ) = @_ ;
        $opts = {} unless ref $opts eq 'HASH' ;

#       my $edit_code = shift ;
#       my $file_name = shift ;
#       my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;

#print "FILE $file_name\n" ;

# delete unsupported options

        my @bad_opts =
                grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;

        delete @{$opts}{@bad_opts} ;

# keep the user err_mode and force croaking on internal errors

        my $err_mode = delete $opts->{err_mode} ;
        $opts->{ err_mode } = 'croak' ;

# get a scalar ref for speed and slurp the file into a scalar

        $opts->{ scalar_ref } = 1 ;
        my $existing_data = eval { read_file( $file_name, $opts ) } ;

        if ( $@ ) {

                @_ = ( { err_mode => $err_mode },
                        "edit_file '$file_name' - read_file: $!" ) ;
                goto &_error ;
        }

#print "EXIST [$$existing_data]\n" ;

        my( $edited_data ) = map { $edit_code->(); $_ } $$existing_data ;

        $opts->{atomic} = 1 ;
        my $write_result =
                eval { write_file( $file_name, $opts, $edited_data ) } ;

        if ( $@ ) {

                @_ = ( { err_mode => $err_mode },
                        "edit_file '$file_name' - write_file: $!" ) ;
                goto &_error ;
        }

        return $write_result ;
}

*efl = \&edit_file_lines ;

sub edit_file_lines(&$;$) {

        my( $edit_code, $file_name, $opts ) = @_ ;
        $opts = {} unless ref $opts eq 'HASH' ;

#       my $edit_code = shift ;
#       my $file_name = shift ;
#       my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;

#print "FILE $file_name\n" ;

# delete unsupported options

        my @bad_opts =
                grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;

        delete @{$opts}{@bad_opts} ;

# keep the user err_mode and force croaking on internal errors

        my $err_mode = delete $opts->{err_mode} ;
        $opts->{ err_mode } = 'croak' ;

# get an array ref for speed and slurp the file into lines

        $opts->{ array_ref } = 1 ;
        my $existing_data = eval { read_file( $file_name, $opts ) } ;

        if ( $@ ) {

                @_ = ( { err_mode => $err_mode },
                        "edit_file_lines '$file_name' - read_file: $!" ) ;
                goto &_error ;
        }

#print "EXIST [$$existing_data]\n" ;

        my @edited_data = map { $edit_code->(); $_ } @$existing_data ;

        $opts->{atomic} = 1 ;
        my $write_result =
                eval { write_file( $file_name, $opts, @edited_data ) } ;

        if ( $@ ) {

                @_ = ( { err_mode => $err_mode },
                        "edit_file_lines '$file_name' - write_file: $!" ) ;
                goto &_error ;
        }

        return $write_result ;
}

# basic wrapper around opendir/readdir

sub read_dir {

        my $dir = shift ;
        my $opts = ( ref $_[0] eq 'HASH' ) ? shift : { @_ } ;

# this handle will be destroyed upon return

        local(*DIRH);

# open the dir and handle any errors

        unless ( opendir( DIRH, $dir ) ) {

                @_ = ( $opts, "read_dir '$dir' - opendir: $!" ) ;
                goto &_error ;
        }

        my @dir_entries = readdir(DIRH) ;

        @dir_entries = grep( $_ ne "." && $_ ne "..", @dir_entries )
                unless $opts->{'keep_dot_dot'} ;

        if ( $opts->{'prefix'} ) {

                $_ = File::Spec->catfile($dir, $_) for @dir_entries;
        }

        return @dir_entries if wantarray ;
        return \@dir_entries ;
}

# error handling section
#
# all the error handling uses magic goto so the caller will get the
# error message as if from their code and not this module. if we just
# did a call on the error code, the carp/croak would report it from
# this module since the error sub is one level down on the call stack
# from read_file/write_file/read_dir.


my %err_func = (
        'carp'  => \&carp,
        'croak' => \&croak,
) ;

sub _error {

        my( $opts, $err_msg ) = @_ ;

# get the error function to use

        my $func = $err_func{ $opts->{'err_mode'} || 'croak' } ;

# if we didn't find it in our error function hash, they must have set
# it to quiet and we don't do anything.

        return unless $func ;

# call the carp/croak function

        $func->($err_msg) if $func ;

# return a hard undef (in list context this will be a single value of
# undef which is not a legal in-band value)

        return undef ;
}

1;
__END__

@

@c _____________________________________

@node Package File-Slurp Perldoc
@subsubsection Package File::Slurp Perldoc
@cindex package File::Slurp perldoc
@cindex perldoc for package File::Slurp

@<Package---File--Slurp-Perldoc@>=
=head1 NAME

File::Slurp - Simple and Efficient Reading/Writing/Modifying of Complete Files

=head1 SYNOPSIS

  use File::Slurp;

  # read in a whole file into a scalar
  my $text = read_file('/path/file');

  # read in a whole file into an array of lines
  my @lines = read_file('/path/file');

  # write out a whole file from a scalar
  write_file('/path/file', $text);

  # write out a whole file from an array of lines
  write_file('/path/file', @lines);

  # Here is a simple and fast way to load and save a simple config file
  # made of key=value lines.
  my %conf = read_file('/path/file') =~ /^(\w+)=(.*)$/mg;
  write_file('/path/file', {atomic => 1}, map "$_=$conf{$_}\n", keys %conf);

  # insert text at the beginning of a file
  prepend_file('/path/file', $text);

  # in-place edit to replace all 'foo' with 'bar' in file
  edit_file { s/foo/bar/g } '/path/file';

  # in-place edit to delete all lines with 'foo' from file
  edit_file_lines sub { $_ = '' if /foo/ }, '/path/file';

  # read in a whole directory of file names (skipping . and ..)
  my @files = read_dir('/path/to/dir');

=head1 DESCRIPTION

This module provides subs that allow you to read or write entire files
with one simple call. They are designed to be simple to use, have
flexible ways to pass in or get the file contents and to be very
efficient. There is also a sub to read in all the files in a
directory.

=head2 WARNING - PENDING DOOM

Although you technically I<can>, do NOT use this module to work on file handles,
pipes, sockets, standard IO, pseudo-files, or the C<DATA> handle. These are
features implemented long ago that just really shouldn't be abused here.

Be warned: this activity will lead to inaccurate encoding/decoding of data.

All further mentions of actions on the above have been removed from this
documentation and that feature set will likely be deprecated in the future.

In other words, if you don't have a filename to pass, consider using the
standard C<< do { local $/; <$fh> } >>, or
L<Data::Section>/L<Data::Section::Simple> for working with C<__DATA__>.

=head1 FUNCTIONS

L<File::Slurp> implements the following functions.

=head2 append_file

        use File::Spec qw(append_file write_file);
        my $res = append_file('/path/file', "Some text");
        # same as
        my $res = write_file('/path/file', {append => 1}, "Some text");

The C<append_file> function is simply a synonym for the
L<File::Slurp/"write_file"> function, but ensures that the C<append> option is
set.

=head2 edit_file

        use File::Slurp qw(edit_file);
        # perl -0777 -pi -e 's/foo/bar/g' /path/file
        edit_file { s/foo/bar/g } '/path/file';
        edit_file sub { s/foo/bar/g }, '/path/file';
        sub replace_foo { s/foo/bar/g }
        edit_file \&replace_foo, '/path/file';

The C<edit_file> function reads in a file into C<$_>, executes a code block that
should modify C<$_>, and then writes C<$_> back to the file. The C<edit_file>
function reads in the entire file and calls the code block one time. It is
equivalent to the C<-pi> command line options of Perl but you can call it from
inside your program and not have to fork out a process.

The first argument to C<edit_file> is a code block or a code reference. The
code block is not followed by a comma (as with C<grep> and C<map>) but a code
reference is followed by a comma.

The next argument is the filename.

The next argument(s) is either a hash reference or a flattened hash,
C<< key => value >> pairs. The options are passed through to the
L<File::Slurp/"write_file"> function. All options are described there.
Only the C<binmode> and C<err_mode> options are supported. The call to
L<File::Slurp/"write_file"> has the C<atomic> option set so you will always
have a consistent file.

=head2 edit_file_lines

        use File::Slurp qw(edit_file_lines);
        # perl -pi -e '$_ = "" if /foo/' /path/file
        edit_file_lines { $_ = '' if /foo/ } '/path/file';
        edit_file_lines sub { $_ = '' if /foo/ }, '/path/file';
        sub delete_foo { $_ = '' if /foo/ }
        edit_file \&delete_foo, '/path/file';

The C<edit_file_lines> function reads each line of a file into C<$_>, and
executes a code block that should modify C<$_>. It will then write C<$_> back
to the file. It is equivalent to the C<-pi> command line options of Perl but
you can call it from inside your program and not have to fork out a process.

The first argument to C<edit_file_lines> is a code block or a code reference.
The code block is not followed by a comma (as with C<grep> and C<map>) but a
code reference is followed by a comma.

The next argument is the filename.

The next argument(s) is either a hash reference or a flattened hash,
C<< key => value >> pairs. The options are passed through to the
L<File::Slurp/"write_file"> function. All options are described there.
Only the C<binmode> and C<err_mode> options are supported. The call to
L<File::Slurp/"write_file"> has the C<atomic> option set so you will always
have a consistent file.

=head2 ef

        use File::Slurp qw(ef);
        # perl -0777 -pi -e 's/foo/bar/g' /path/file
        ef { s/foo/bar/g } '/path/file';
        ef sub { s/foo/bar/g }, '/path/file';
        sub replace_foo { s/foo/bar/g }
        ef \&replace_foo, '/path/file';

The C<ef> function is simply a synonym for the L<File::Slurp/"edit_file">
function.

=head2 efl

        use File::Slurp qw(efl);
        # perl -pi -e '$_ = "" if /foo/' /path/file
        efl { $_ = '' if /foo/ } '/path/file';
        efl sub { $_ = '' if /foo/ }, '/path/file';
        sub delete_foo { $_ = '' if /foo/ }
        efl \&delete_foo, '/path/file';

The C<efl> function is simply a synonym for the L<File::Slurp/"edit_file_lines">
function.

=head2 overwrite_file

        use File::Spec qw(overwrite_file);
        my $res = overwrite_file('/path/file', "Some text");

The C<overwrite_file> function is simply a synonym for the
L<File::Slurp/"write_file"> function.

=head2 prepend_file

        use File::Slurp qw(prepend_file);
        prepend_file('/path/file', $header);
        prepend_file('/path/file', \@lines);
        prepend_file('/path/file', { binmode => 'raw:'}, $bin_data);

        # equivalent to:
        use File::Slurp qw(read_file write_file);
        my $content = read_file('/path/file');
        my $new_content = "hahahaha";
        write_file('/path/file', $new_content . $content);

The C<prepend_file> function is the opposite of L<File::Slurp/"append_file"> as
it writes new contents to the beginning of the file instead of the end. It is a
combination of L<File::Slurp/"read_file"> and L<File::Slurp/"write_file">. It
works by first using C<read_file> to slurp in the file and then calling
C<write_file> with the new data and the existing file data.

The first argument to C<prepend_file> is the filename.

The next argument(s) is either a hash reference or a flattened hash,
C<< key => value >> pairs. The options are passed through to the
L<File::Slurp/"write_file"> function. All options are described there.

Only the C<binmode> and C<err_mode> options are supported. The
C<write_file> call has the C<atomic> option set so you will always have
a consistent file.

=head2 read_dir

        use File::Spec qw(read_dir);
        my @files = read_dir('/path/to/dir');
        # all files, even the dots
        my @files = read_dir('/path/to/dir', keep_dot_dot => 1);
        # keep the full file path
        my @paths = read_dir('/path/to/dir', prefix => 1);
        # scalar context
        my $files_ref = read_dir('/path/to/dir');

This function returns a list of the filenames in the supplied directory. In
list context, an array is returned, in scalar context, an array reference is
returned.

The first argument is the path to the directory to read.

The next argument(s) is either a hash reference or a flattened hash,
C<< key => value >> pairs. The following options are available:

=over

=item

err_mode

The C<err_mode> option has three possible values: C<quiet>, C<carp>, or the
default, C<croak>. In C<quiet> mode, all errors will be silent. In C<carp> mode,
all errors will be emitted as warnings. And, in C<croak> mode, all errors will
be emitted as exceptions. Take a look at L<Try::Tiny> or
L<Syntax::Keyword::Try> to see how to catch exceptions.

=item

keep_dot_dot

The C<keep_dot_dot> option is a boolean option, defaulted to false (C<0>).
Setting this option to true (C<1>) will also return the C<.> and C<..> files
that are removed from the file list by default.

=item

prefix

The C<prefix> option is a boolean option, defaulted to false (C<0>).
Setting this option to true (C<1>) add the directory as a prefix to the file.
The directory and the filename are joined using C<< File::Spec->catfile() >> to
ensure the proper directory separator is used for your OS. See L<File::Spec>.

=back

=head2 read_file

        use File::Slurp qw(read_file);
        my $text = read_file('/path/file');
        my $bin = read_file('/path/file', { binmode => ':raw' });
        my @lines = read_file('/path/file');
        my $lines_ref = read_file('/path/file', array_ref => 1);
        my $lines_ref = [ read_file('/path/file') ];

        # or we can read into a buffer:
        my $buffer;
        read_file('/path/file', buf_ref => \$buffer);

        # or we can set the block size for the read
        my $text_ref = read_file('/path/file', blk_size => 10_000_000, array_ref => 1);

        # or we can get a scalar reference
        my $text_ref = read_file('/path/file', scalar_ref => 1);

This function reads in an entire file and returns its contents to the
caller. In scalar context it returns the entire file as a single
scalar. In list context it will return a list of lines (using the
current value of C<$/> as the separator, including support for paragraph
mode when it is set to C<''>).

The first argument is the path to the file to be slurped in.

The next argument(s) is either a hash reference or a flattened hash,
C<< key => value >> pairs. The following options are available:

=over

=item

array_ref

The C<array_ref> option is a boolean option, defaulted to false (C<0>). Setting
this option to true (C<1>) will only have relevance if the C<read_file> function
is called in scalar context. When true, the C<read_file> function will return
a reference to an array of the lines in the file.

=item

binmode

The C<binmode> option is a string option, defaulted to empty (C<''>). If you
set the C<binmode> option, then its value is passed to a call to C<binmode> on
the opened handle. You can use this to set the file to be read in binary mode,
utf8, etc. See C<perldoc -f binmode> for more.

=item

blk_size

You can use this option to set the block size used when slurping from
an already open handle (like C<\*STDIN>). It defaults to 1MB.

=item

buf_ref

The C<buf_ref> option can be used in conjunction with any of the other options.
You can use this option to pass in a scalar reference and the slurped
file contents will be stored in the scalar. This saves an extra copy of
the slurped file and can lower RAM usage vs returning the file. It is
usually the fastest way to read a file into a scalar.

=item

chomp

The C<chomp> option is a boolean option, defaulted to false (C<0>). Setting
this option to true (C<1>) will cause each line to have its contents C<chomp>ed.
This option works in list context or in scalar context with the C<array_ref>
option.

=item

err_mode

The C<err_mode> option has three possible values: C<quiet>, C<carp>, or the
default, C<croak>. In C<quiet> mode, all errors will be silent. In C<carp> mode,
all errors will be emitted as warnings. And, in C<croak> mode, all errors will
be emitted as exceptions. Take a look at L<Try::Tiny> or
L<Syntax::Keyword::Try> to see how to catch exceptions.

=item

scalar_ref

The C<scalar_ref> option is a boolean option, defaulted to false (C<0>). It only
has meaning in scalar context. The return value will be a scalar reference to a
string which is the contents of the slurped file. This will usually be faster
than returning the plain scalar. It will also save memory as it will not make a
copy of the file to return.

=back

=head2 rf

        use File::Spec qw(rf);
        my $text = rf('/path/file');

The C<rf> function is simply a synonym for the L<File::Slurp/"read_file">
function.

=head2 slurp

        use File::Spec qw(slurp);
        my $text = slurp('/path/file');

The C<slurp> function is simply a synonym for the L<File::Slurp/"read_file">
function.

=head2 wf

        use File::Spec qw(wf);
        my $res = wf('/path/file', "Some text");


The C<wf> function is simply a synonym for the
L<File::Slurp/"write_file"> function.

=head2 write_file

        use File::Slurp qw(write_file);
        write_file('/path/file', @data);
        write_file('/path/file', {append => 1}, @data);
        write_file('/path/file', {binmode => ':raw'}, $buffer);
        write_file('/path/file', \$buffer);
        write_file('/path/file', $buffer);
        write_file('/path/file', \@lines);
        write_file('/path/file', @lines);

        # binmode
        write_file('/path/file', {binmode => ':raw'}, @data);
        write_file('/path/file', {binmode => ':utf8'}, $utf_text);

        # buffered
        write_file('/path/file', {buf_ref => \$buffer});
        write_file('/path/file', \$buffer);
        write_file('/path/file', $buffer);

        # append
        write_file('/path/file', {append => 1}, @data);

        # no clobbering
        write_file('/path/file', {no_clobber => 1}, @data);

This function writes out an entire file in one call. By default C<write_file>
returns C<1> upon successfully writing the file or C<undef> if it encountered
an error. You can change how errors are handled with the C<err_mode> option.

The first argument to C<write_file> is the filename.

The next argument(s) is either a hash reference or a flattened hash,
C<< key => value >> pairs. The following options are available:

=over

=item

append

The C<append> option is a boolean option, defaulted to false (C<0>). Setting
this option to true (C<1>) will cause the data to be be written at the end of
the current file. Internally this sets the C<sysopen> mode flag C<O_APPEND>.

The L<File::Slurp/"append_file"> function sets this option by default.

=item

atomic

The C<atomic> option is a boolean option, defaulted to false (C<0>). Setting
this option to true (C<1>) will cause the file to be be written to in an
atomic fashion. A temporary file name is created by appending the pid
(C<$$>) to the file name argument and that file is spewed to. After the
file is closed it is renamed to the original file name (and C<rename> is
an atomic operation on most OSes). If the program using this were to
crash in the middle of this, then the file with the pid suffix could
be left behind.

=item

binmode

The C<binmode> option is a string option, defaulted to empty (C<''>). If you
set the C<binmode> option, then its value is passed to a call to C<binmode> on
the opened handle. You can use this to set the file to be read in binary mode,
utf8, etc. See C<perldoc -f binmode> for more.

=item

buf_ref

The C<buf_ref> option is used to pass in a scalar reference which has the
data to be written. If this is set then any data arguments (including
the scalar reference shortcut) in C<@_> will be ignored.

=item

err_mode

The C<err_mode> option has three possible values: C<quiet>, C<carp>, or the
default, C<croak>. In C<quiet> mode, all errors will be silent. In C<carp> mode,
all errors will be emitted as warnings. And, in C<croak> mode, all errors will
be emitted as exceptions. Take a look at L<Try::Tiny> or
L<Syntax::Keyword::Try> to see how to catch exceptions.


=item

no_clobber

The C<no_clobber> option is a boolean option, defaulted to false (C<0>). Setting
this option to true (C<1>) will ensure an that existing file will not be
overwritten.

=item

perms

The C<perms> option sets the permissions of newly-created files. This value
is modified by your process's C<umask> and defaults to C<0666> (same as
C<sysopen>).

NOTE: this option is new as of File::Slurp version 9999.14.

=back

=head1 EXPORT

These are exported by default or with

        use File::Slurp qw(:std);
        # read_file write_file overwrite_file append_file read_dir

These are exported with

        use File::Slurp qw(:edit);
        # edit_file edit_file_lines

You can get all subs in the module exported with

        use File::Slurp qw(:all);

=head1 AUTHOR

Uri Guttman, <F<uri@stemsystems.com>>

=head1 COPYRIGHT & LICENSE

Copyright (c) 2003 Uri Guttman. All rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

@




@c .....................................

@node File-Slurp Tests
@subsection @file{File::Slurp} Tests
@cindex @file{File::Slurp} tests
@cindex tests of @file{File::Slurp}

@c _____________________________________

@node List of Tests for File-Slurp
@subsubsection List of Tests for @file{File::Slurp}

@verbatim
t/00-report-prereqs.t
t/01-error_edit_file.t
t/01-error_edit_file_lines.t
t/01-error_prepend_file.t
t/01-error_read_dir.t
t/01-error_read_file.t
t/01-error_write_file.t
t/append_null.t
t/binmode.t
t/data_section.t
t/edit_file.t
t/error.t
t/file_object.t
t/handle.t
t/inode.t
t/large.t
t/lib/FileSlurpTest.pm
t/lib/FileSlurpTestOverride.pm
t/newline.t
t/no_clobber.t
t/original.t
t/paragraph.t
t/perms.t
t/prepend_file.t
t/pseudo.t
t/read_dir.t
t/slurp.t
t/stdin.t
t/stringify.t
t/tainted.t
t/write_file_win32.t
xt/author/00-compile.t
xt/author/eol.t
xt/author/pod-spell.t
xt/author/pod-syntax.t
xt/author/pod_coverage.t
xt/author/test-version.t
@end verbatim


@c .....................................

@node FileSlurpTest Code
@subsection FileSlurpTest Code
@cindex @file{File::Slurp} FileSlurpTest code

@(FileSlurpTest.pm@)=
@<Test---FileSlurp--FileSlurpTest@>
@

@post_create FileSlurpTest.pm printf "${PURPLE}"; mkdir -vp ${PWD}/files/t/lib; mv -v FileSlurpTest.pm ${PWD}/files/t/lib && printf "${GREEN}done moving ${PURPLEBOLD}FileSlurpTest.pm.${CLEAR}\n" || printf "${RED}failed.${CLEAR}\n"

@c _____________________________________

@node FileSlurpTest Code Body
@subsubsection FileSlurpTest Code Body

@<Test---FileSlurp--FileSlurpTest@>=
package FileSlurpTest;

use strict;
use warnings;
use Exporter qw(import);
use IO::Handle ();
use File::Spec ();
use File::Temp qw(tempfile);

use File::Slurp ();

our @EXPORT_OK = qw(
    IS_WSL temp_file_path trap_function trap_function_list_context
);

sub IS_WSL() {
  if ($^O eq 'linux') {
    require POSIX;
    return 1 if (POSIX::uname())[2] =~ /windows/i;
  }
}

sub temp_file_path {
    my ($pick_nonsense_path) = @_;

    # older EUMMs turn this on. We don't want to emit warnings.
    # also, some of our CORE function overrides emit warnings. Silence those.
    local $^W;

    my $file;
    if ($pick_nonsense_path) {
        $file = File::Spec->catfile(File::Spec->tmpdir, 'super', 'bad', 'file-slurp', 'path');
    }
    else {
        (undef, $file) = tempfile('tempXXXXX', DIR => File::Spec->tmpdir, OPEN => 0);
    }
    return $file;
}

sub trap_function {
    my ($function, @args) = @_;
    my $res;
    my $warn;
    my $err = do { # catch
        local $@;
        local $SIG{__WARN__} = sub {$warn = join '', @_};
        eval { # try
            $res = $function->(@args);
            1;
        };
        $@;
    };
    return ($res, $warn, $err);
}

sub trap_function_list_context {
    my ($function, @args) = @_;
    my @res;
    my $warn;
    my $err = do { # catch
        local $@;
        local $SIG{__WARN__} = sub {$warn = join '', @_};
        eval { # try
            @res = $function->(@args);
            1;
        };
        $@;
    };
    return (\@res, $warn, $err);
}

1;

@





@c END SECTION: About File::Slurp
@c /////////////////////////////////////////////////////////////////////////////







@c END CHAPTER: About Packages
@c /////////////////////////////////////////////////////////////////////////////








@c<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
@c APPENDICES
@c<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>








@c *****************************************************************************
@c                              THE MAKEFILE

@node The Makefile
@appendix The Makefile
@cindex makefile

The @file{Makefile} has five initial top-level targets built in as defaults:

@enumerate

@item
Variable Definitions

@itemize
@item
FILE: the name of this source document, without extension
@item
ROOT: the  name of the  root directory, which  defaults to the  present working
directory, $(PWD)
@item
FILES: the  name of  the root directory  for the files  created in  this source
document, which defaults to @file{files}
@item
LODESTONE: a reference file to help @file{Makefile} determine when to recompile
this source document or the @file{TEXI} file
@end itemize

@item
The Default Target: @command{twjr}, described below

@item
The TWJR Targets

@table @command
@item twjrkeep
@command{jrtangle jrweave info pdf html}
@item twjr
@command{twjrkeep dirclean}
@item jrtangle
@command{jrtangle $(FILE).twjr}
@item newmakefile
@command{jrtangle allclean}
@end table

@item
The Clean Targets

@enumerate
@item
Clean
@item
Dirclean
@item
Distclean
@item
Allclean
@end enumerate

@item
The Applications Hook

@end enumerate




@(Makefile@)=
# MAKEFILE FILE CHUNKS
######################

@<Makefile---Variable Definitions@>
@<Makefile---Default Target@>
@<Makefile---TWJR Targets@>
@<Makefile---Clean Targets@>
@<Makefile---Applications@>

@




@c -----------------------------------------------------------------------------

@node Makefile Variable Definitions
@appendixsec Makefile Variable Definitions

The @env{SHELL} variable is included because some shell commands depend upon
Bash version 4, which is not native on my system.

The @env{ROOT} variable is designed to allow you to to extract the source files
(not the @acronym{TEXI}, @acronym{INFO}, @acronym{PDF} or @acronym{HTML} files,
but  the  programs defined  inside  the  @acronym{TWJR}  file) to  a  directory
structure outside of the your  ``present working directory'' (@env{PWD}) should
that be something you want to do, i.e., for production purposes.

The @code{FILE} variable  is the name of this source  @code{TWJR} file, without
extension.

The @code{FILES} variable is the name of  the root directory for the files that
are extracted during the @emph{tangling} phase.  This directory goes underneath
the @file{ROOT} directory.  Feel free to name this whatever you want.

The @code{LODESTONE}  variable is an empty  reference file that is  used solely
for its  modification time  to help  the Makefile  determine when  to recompile
(i.e., @emph{tangle} and @emph{weave}) the  source @file{TWJR} file.  It should
not be changed or otherwise touched (pun intended).

@<Makefile---Variable Definitions@>=
# VARIABLE DEFINITIONS
######################
LODESTONE := .lodestone
README    := README.md
GIT       := .git*

SHELL := $$(which bash)

FILE  := Perl5
ROOT  := $(PWD)
FILES := files

@




@c -----------------------------------------------------------------------------

@node Makefile Default Target
@appendixsec Default Target
@cindex default target

The @code{default} target  extracts all source files and moves  them into their
proper  directories,  and  processes  the   @code{TEXI}  source  file  into  an
@code{INFO}  file, a  @code{PDF} document,  and an  @code{HTML} web  site. This
process automatically updates the TEXI's nodes and sectioning commands prior to
generating  the   INFO,  PDF,  and   HTML  documents.    What  used  to   be  a
manually-intensive process is now completely  automated through a Makefile that
is extracted from the @code{TWJR}  source.

This  automated  process  depends   upon  the  programmer's  system  containing
@file{GNU   AWK}  (for   the   primary  literate   programming  operations   of
@emph{tangling}   and   @emph{weaving}@footnote{No  other   implementation   of
@file{AWK}  will  work}),   @file{make}  (to  control  the   build  and  output
processes@footnote{While I haven't tested it, just about any @file{make} should
work}),  @file{Texinfo} of  at least  version 6.5  (for the  processing of  the
@file{TEXI} output file), @file{makeinfo} (to produce the @file{INFO} file from
the @file{TEXI}  file), and @file{Emacs}  (for the automatic updating  of nodes
and sectioning  command@footnote{Again, while I  haven't tested it,  just about
any @file{Emacs}  should work}).   With these  dependencies, everything  can be
compiled with a single call to @command{make} with no argument:

@example
$ make
@end example

Individual files and documents can also be targeted with simple calls such as:

@example
$ make html

$ make openhtml

$ make pdf

$ make openpdf

$make info

$ make openinfo

$ make distclean

$ make allclean
@end example

@noindent and so forth (just name a few).

The target  @code{twjr} is  the default, and  does everything  explicitly.  The
target @code{weave}  (or alternatively @code{texi})  will run just  the command
@command{jrweave}  on the  @file{TWJR} file  to produce  the @file{TEXI}  file,
which  is  directly  responsible  for  producing  the  output  files.   If  the
@file{TWJR}  source  file has  been  modified,  then @command{maked}  will  run
@command{jrtangle} first to update all source documents.

@<Makefile---Default Target@>=
# DEFAULT Target
################
.PHONY : TWJR JRTANGLE TANGLE JRWEAVE WEAVE TEXI INFO PDF HTML
.PHONY : default twjr twjrkeep jrtangle tangle
.PHONY : jrweave weave texi info pdf html newmakefile

default : TWJR

@




@c -----------------------------------------------------------------------------


@node Makefile TWJR Targets
@appendixsec TWJR Targets
@cindex TWJR targets

These targets are all related to processing the main source @acronym{TWJR} file
in some  way. The @file{make} target  @command{twjr} is the default  target and
runs each of the processes  @command{jrtangle} and @command{jrweave} to produce
source files,  a @acronym{TEXI} file,  an @acronym{INFO} file,  a @acronym{PDF}
document, and an @acronym{HTML} web site.  It only sources what is necessary as
@file{make} is designed to do.  Note that at this time, @emph{weaving} includes
automatic  menu and  node  updating  of the  @acronym{TEXI}  file,  so that  an
@acronym{INFO} file  can also be  generated without needing to  manually update
the  @acronym{TEXI} file  first  as used  to be  the  case. @file{make}  target
@code{info}     runs     @command{makeinfo},     target     @code{pdf}     runs
@command{pdftexi2dvi}, and target @code{html} runs @command{makeinfo --html}.

The default @file{twjr} target deletes all extraneous build and log files prior
to finishing.   If you want  to retain  the build and  log files, then  run the
target @file{twjrkeep} instead.

The  file  @file{.lodestone}   is  used  to  set  a  reference   time  for  the

@acronym{TWJR} file,  so that  if the @acronym{TWJR}  file changes,  new source
documents will be generated; otherwise, it  will simply be left alone. In other
words, if @file{.lodestone}  is older than @file{.twjr},  then @file{.twjr} has
been modified, and it should be @emph{tangled} and @emph{woven} first.  If it is
newer, then @command{make} will not recompile.

Should the @file{Makefile}  portion of the @file{TWJR} be modified,  then it is
important to  obtain a fresh copy  of the @file{Makefile} prior  to running any
target; therefore,  use the target  @command{make newmakefile} first,  then run
any desired target.

@<Makefile---TWJR Targets@>=
# TWJR TARGETS
##############

# Process everything; don't remove any build or log files;
twjrkeep : jrtangle jrweave info pdf html

# Process everything; remove build files and logs.
TWJR : twjr
twjr : twjrkeep dirclean

# JRTANGLE depends upon the LODESTONE and the ROOT/FILES directory;
# if either is missing or out of date, then JRTANGLE will be run to
# extract its files.
JRTANGLE : TANGLE
TANGLE   : jrtangle
jrtangle : tangle
tangle   : files $(LODESTONE)

# Checks the relative time to determine if JRTANGLE should be rerun
$(LODESTONE) : $(FILE).twjr
	@printf "${YELLOW}Tangling $(FILE)...${CLEAR}\n"
	@jrtangle $(FILE).twjr
	@touch $(LODESTONE)
	@printf "${GREEN}done tangling.${CLEAR}\n"

# Checks for  the existence  of the ROOT/FILES  directory; extracts  files into
# them if they don't  exist or are out of date; they must  be retouched if they
# exist but  are out of date  because they will  not be remade or  updated when
# files are extracted into them
files : $(ROOT)/$(FILES)
$(ROOT)/$(FILES) : $(FILE).twjr
	@printf "${YELLOW}Creating files...${CLEAR}\n"
	@touch $(FILE).twjr
	@make $(LODESTONE)
	@touch $(ROOT)/$(FILES)
	@printf "${GREEN}done creating files.${CLEAR}\n"

# Extracts the Makefile if necessary by tangling; everything else
# is thereafter deleted
newmakefile : $(LODESTONE) allclean

# Extracts the TEXI, and updates the nodes and sections with a batch call to
# Emacs; it depends upon TWJR
JRWEAVE : WEAVE
WEAVE   : TEXI
TEXI    : jrweave
jrweave : weave
weave   : texi
texi    : $(FILE).texi
$(FILE).texi : $(FILE).twjr
	@printf "${YELLOW}Weaving $(FILE)...${CLEAR}\n"
	@jrweave $(FILE).twjr > $(FILE).texi
	@printf "${GREEN}done weaving.${CLEAR}\n";
	@printf "${YELLOW}updating $(FILE)'s menus and nodes...${CLEAR}\n"
	@emacs --batch --eval '(progn (find-file "./$(FILE).texi" nil) \
	  (texinfo-master-menu 1) (save-buffer 0))' 2> .batch.log
	@printf "${GREEN}done updating.${CLEAR}\n"

# Runs makeinfo on the TEXI file;
# Opens the INFO file in Emacs
INFO : info
info : $(FILE).info
$(FILE).info : $(FILE).texi
	@printf "${YELLOW}Creating an INFO file...${CLEAR}\n"
	@makeinfo $(FILE).texi
	@printf "${GREEN}done${CLEAR}\n"
openinfo : INFO
	@printf "${YELLOW}Opening INFO in Emacs...${CLEAR}\n"
	@emacsclient -s server --eval '(info "($(ROOT)/$(FILE).info)top")'
	@printf "${GREEN}done${CLEAR}\n"

# Runs pdftexi2dvi on the TEXI file;
# Opens the PDF file
PDF : pdf
pdf : $(FILE).pdf
$(FILE).pdf : $(FILE).texi
	@printf "${YELLOW}Creating a PDF file...${CLEAR}\n"
	@pdftexi2dvi --build=tidy --build-dir=build --quiet $(FILE).texi
	@printf "${GREEN}done${CLEAR}\n"
openpdf : PDF
	@printf "${YELLOW}Opening PDF...${CLEAR}\n"
	@open $(FILE).pdf
	@printf "${GREEN}done${CLEAR}\n"

# Runs makeinfo --html on the TEXI file;
# Opens index.html in a browser
HTML : html
html : $(FILE)/index.html
$(FILE)/index.html : $(FILE).texi
	@printf "${YELLOW}Creating an HTML directory...${CLEAR}\n"
	@makeinfo --html $(FILE).texi
	@printf "${GREEN}done${CLEAR}\n"
openhtml : HTML
	@printf "${YELLOW}Opening INDEX.HTML in the browser...${CLEAR}\n"
	@open $(FILE)/index.html
	@printf "${GREEN}done${CLEAR}\n"

@




@c -----------------------------------------------------------------------------

@node Makefile Clean Targets
@appendixsec Makefile Clean Targets
@cindex Makefile clean targets

The @command{clean} target removes  backup files. The @command{dirclean} target
removes build  directories and log  files, but  not source files  (those inside
@file{files} directory,  e.g., @file{bin/} and and  @file{src/}) and associated
files and  programs inside  them.  The  @command{distclean} target  removes the
@acronym{INFO}, @acronym{PDF},  @acronym{HTML}, and @acronym{source}  files and
directories, leaving just  the @file{TWJR} file, the @file{TEXI}  file, and the
@file{Makefile}.  Finally,  the  @command{allclean} target  removes  everything
except the @acronym{TWJR} file and the @file{Makefile}.

@<Makefile---Clean Targets@>=
.PHONY : clean dirclean distclean worldclean allclean

# remove backup files
clean :
	@printf "${WHITEBOLD}Cleaning...${CYAN}\n"
	@rm -f *~ .*~ #*# #*.*#
	@printf "${GREEN}done cleaning.${CLEAR}\n"

# after clean:  remove all  build and miscellaneous  files, leaving  only TWJR,
# TEXI,  INFO, HTML,  PDF,  Makefile,  README, .git,  .gitignore  & the  source
# documents.

dirclean : clean
	@printf "${WHITEBOLD}Dir-cleaning...${CYAN}\n"
	@for file in * .*; do      \
	  case $$file in           \
            '.' | '..')          ;;\
	    $(FILE)* | Makefile) ;;\
	    $(FILES)*)	 	 ;;\
	    $(LODESTONE))        ;;\
	    $(README))		 ;;\
	    $(GIT))		 ;;\
            *) rm -vfr $$file	 ;;\
	  esac                     \
	done
	@printf "${GREEN}done dir-cleaning.${CLEAR}\n"

# after dirclean: remove INFO, HTML, and PDF, and FILES
distclean : dirclean
	@printf "${WHITEBOLD}Dist-cleaning...${CYAN}\n"
	@rm -vfr $(FILE) $(FILE).info $(FILE).pdf $(ROOT)/$(FILES)
	@printf "${GREEN}done dist-cleaning.${CLEAR}\n"

# allclean: remove TEXI, leaving only TWJR and Makefile
allclean : distclean
	@printf "${WHITEBOLD}Cleaning all...${CYAN}\n"
	@rm -vfr $(FILE).texi
	@printf "${GREEN}done cleaning all.${CLEAR}\n"

@




@c -----------------------------------------------------------------------------

@node Makefile Applications
@appendixsec Makefile Applications
@cindex Makefile applications

Place any targets for running  code-specific commands here, such as executables
in the @file{bin/} directory.  The file @verb{|@<Makefile---Applicaionts@>|} is
a hook  that can  be used in  another part  of the source  document; this  is a
fundamental feature of literate programming.

@<Makefile---Applications@>=
@


@c END The Makefile
@c /////////////////////////////////////////////////////////////////////////////








@c *****************************************************************************
@c                        CODE CHUNK SUMMARIES

@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@menu
* File Definitions::          Source files by definition.
* Code Chunk Definitions::    Code chunks by definition.
* Code Chunk References::     Code chunks by reference.
@end menu




@c -----------------------------------------------------------------------------
@node File Definitions
@appendixsec Source File Definitions

@print_file_defs




@c -----------------------------------------------------------------------------
@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs




@c -----------------------------------------------------------------------------
@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs


@c END Code Chunk Summaries
@c /////////////////////////////////////////////////////////////////////////////








@c <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
@part Back Matter
@c <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>








@c *****************************************************************************
@c                                BIBLIOGRAPHY

@node Bibliography
@unnumbered Bibliography

@c @table @asis

@c @mybibitem{LitProg:Home}
@c "On Misreadings", email, January 2009 @url{http://www.literateprogramming.com/}

@c @mybibitem{LitProg:Knuth}
@c @url{``Literate Programming (1984)'' in Literate Programming. CSLI, 1992, pg.
@c 99.}

@c @mybibitem{LitProg:Ramsey}
@c @url{ahttps://www.cs.tufts.edu/~nr/noweb/}

@c @end table


@c END Bibliography
@c /////////////////////////////////////////////////////////////////////////////








@c *****************************************************************************
@c                             LIST OF TABLES

@node List of Tables
@unnumbered List of Tables

@listoffloats Table







@c END Lists
@c /////////////////////////////////////////////////////////////////////////////








@c  *****************************************************************************
@c                               CONCEPT INDEX


@node Concept Index
@unnumbered Index

@printindex cp


@c END Indices
@c /////////////////////////////////////////////////////////////////////////////








@bye

TODO:
